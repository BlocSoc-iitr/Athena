package athena_abi
import (
	"fmt"
	"reflect"
)
// The function takes in a list of type definitions (dict) and returns a dict of sets (map[string]bool)
func BuildTypeGraph(typeDefs []map[string]interface{}) map[string]map[string]bool {
	fmt.Println()
	fmt.Println("typdefs os ",typeDefs)
	fmt.Println()
	fmt.Println("the types of typdefs is ",reflect.TypeOf(typeDefs))
	fmt.Println()
	outputGraph := make(map[string]map[string]bool)
	for _, typeDef := range typeDefs {
		referencedTypes := []string{}
		fmt.Println("the typedef is ",typeDef)
		fmt.Println()
	    fmt.Println("the types of typdef is ",reflect.TypeOf(typeDef))
		fmt.Println()
		if typeDef["type"] == "struct" {
			/*for _, member := range typeDef["members"].([]map[string]interface{}) {
				referencedTypes = append(referencedTypes, member["type"].(string))
			}*/
			fmt.Println("the type of typedef.member",reflect.TypeOf(typeDef["members"]))
			//fmt.Println("the typedef is ",typeDef["member"])
			members, ok := typeDef["members"].([]map[string]interface {})
			fmt.Println()
			fmt.Println("ok is ",ok)
			/*if !ok {
				
				panic("Expected members to be a slice of interface{}")
			}*/

			// Loop over each element in the slice
			for _, memberInterface := range members {
				// Assert that each element is a map[string]interface{}
				member, ok := memberInterface.(map[string]interface{})
				if !ok {
					panic("Expected each member to be a map[string]interface{}")
				}

				// Now you can safely access member["type"].(string)
				referencedTypes = append(referencedTypes, member["type"].(string))
			}

		} else {
			/*for _, variant := range typeDef["variants"].([]map[string]interface{}) {
				referencedTypes = append(referencedTypes, variant["type"].(string))
			}*/
			// Assert that typeDef["variants"] is a slice of interfaces ([]interface{})
			variants, ok := typeDef["variants"].([]interface{})
			if !ok {
				panic("Expected variants to be a slice of interface{}")
			}

			// Loop over each element in the slice
			for _, variantInterface := range variants {
				// Assert that each element is a map[string]interface{}
				variant, ok := variantInterface.(map[string]interface{})
				if !ok {
					panic("Expected each variant to be a map[string]interface{}")
				}

				// Now you can safely access variant["type"].(string)
				referencedTypes = append(referencedTypes, variant["type"].(string))
			}

		}

		refTypes := make(map[string]bool)

		for _, typeStr := range referencedTypes {
			if _, ok := StarknetCoreTypes[typeStr]; ok {
				continue
			}

			if _, ok := StarknetCoreTypes[extractInnerType(typeStr)]; ok {
				if strings.HasPrefix(typeStr, "core::array") || strings.HasPrefix(typeStr, "@core::array") {
					continue
				}
			}

			refTypes[typeStr] = true
		}

		outputGraph[typeDef["name"].(string)] = refTypes
	}

	return outputGraph
}
